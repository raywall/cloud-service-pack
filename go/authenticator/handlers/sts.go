package handlers

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// STSAuthHandler implementa [AuthHandler] para validar tokens JWT.
type STSAuthHandler struct {
	tokenServiceUrl *string
	credentials     *Credential
	options         *Options
	client          *http.Client
}

// NewSTSAuthHandler creates a new [AuthHandler] for a Security Token Service (STS).
func NewSTSAuthHandler(tokenServiceUrl string, credential *Credential, options *Options) *STSAuthHandler {
	httpClient := &http.Client{
		Timeout: 15 * time.Second,
	}
	if options != nil {
		transport := &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: options.InsecureSkipVerify, // WARNING: Use with caution in production
			},
		}
		httpClient.Transport = transport
	}
	handler := &STSAuthHandler{
		tokenServiceUrl: &tokenServiceUrl,
		credentials:     credential,
		options:         options,
		client:          httpClient,
	}
	return handler
}

// Authenticate performs the authentication of credentials and obtains the
// access token generated by the Security Token Service (STS)
func (h *STSAuthHandler) Authenticate(ctx context.Context) (*Principal, error) {
	var token struct {
		Active       bool   `json:"active"`
		ExpiresIn    int    `json:"expires_in"`
		RefreshToken string `json:"refresh_token"`
		Scopes       string `json:"scope"`
		AccessToken  string `json:"access_token"`
		TokenType    string `json:"token_type"`
	}

	// Prepare the requisition payload
	payload := url.Values{}
	payload.Add("grant_type", "client_credentials")
	payload.Add("client_id", h.credentials.ClientID)
	payload.Add("client_secret", h.credentials.ClientSecret)

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"POST",
		*h.tokenServiceUrl,
		strings.NewReader(payload.Encode()))

	if err != nil {
		return nil, fmt.Errorf("authentication failure: create request: %v", err)
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	// Process the authentication request
	resp, err := h.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("authentication failure: process authentication: %v", err)
	}
	defer resp.Body.Close()

	// Check the status of the authentication response
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("authentication failure: status %v", resp.Status)
	}
	if err := json.NewDecoder(resp.Body).Decode(&token); err != nil {
		return nil, fmt.Errorf("authentication failure: decoding authentication response: %v", err)
	}

	principal := &Principal{
		ID:          h.credentials.ClientID,
		Scopes:      strings.Split(token.Scopes, ","),
		Extra:       make(map[string]interface{}, 0),
		AccessToken: &token.AccessToken,
		ExpiresAt:   time.Now().Add(time.Duration(token.ExpiresIn) * time.Second),
	}
	_ = json.NewDecoder(resp.Body).Decode(&principal.Extra)

	return principal, nil
}
